# Distribuição de horas por objetivo, resultados, entregas ou outros.
```dataviewjs
// Define the folder containing the daily notes
const folder = "050_agenda/050.1_daily";

// Parse the current file name to get the week number and year
const currentFileName = dv.current().file.name; // E.g., "2024-W52"
const weekMatch = currentFileName.match(/(\d{4})-W(\d{2})/);

// Ensure the file name matches the expected format
if (!weekMatch) {
  dv.paragraph("Error: Current file name is not in the expected format (gggg-[W]ww).");
} else {
  const [_, year, weekNumber] = weekMatch.map(Number);

  // Function to get the start and end dates of a given ISO week (starting on Sunday)
  function getWeekDates(year, week) {
    const firstDayOfYear = new Date(year, 0, 1);
    const daysToAdd = (week - 1) * 7 - firstDayOfYear.getDay(); // Adjust to Sunday
    const start = new Date(firstDayOfYear);
    start.setDate(start.getDate() + daysToAdd);
    const end = new Date(start);
    end.setDate(start.getDate() + 6); // End is 6 days after start
    return { start, end };
  }

  // Calculate the start and end dates for the current week
  const { start, end } = getWeekDates(year, weekNumber);

  // Initialize an object to store the sum of durations grouped by objective
  let objectiveDurations = {};

  // Query all pages in the specified folder
  dv.pages(`"${folder}"`)
    .file
    .tasks
    .forEach(task => {
      // Extract the date from the file name (assuming format is YYYY-MM-DD)
      const fileDateMatch = task.path.match(/(\d{4}-\d{2}-\d{2})/);

      // Skip tasks if the file date is not found
      if (!fileDateMatch) return;

      // Parse the file date for comparison
      const fileDate = fileDateMatch[1];
      const taskDate = new Date(fileDate);

      // Check if the task date is within the current week range
      if (taskDate < start || taskDate > end) return;

      // Extract the time range from the task description (e.g., "13:10 - 13:40")
      const timeRange = task.text.match(/(\d{2}):(\d{2}) - (\d{2}):(\d{2})/);
      if (!timeRange) return;

      // Convert times to minutes since midnight
      const startMinutes = parseInt(timeRange[1]) * 60 + parseInt(timeRange[2]);
      const endMinutes = parseInt(timeRange[3]) * 60 + parseInt(timeRange[4]);

      // Calculate the duration in minutes
      const duration = endMinutes - startMinutes;

      // Extract the objective link (if it exists)
      const objectiveMatch = task.text.match(/\[\[([^\]]+)\]\]/);
      const objective = objectiveMatch ? objectiveMatch[1] : "Entrega não cadastrada";

      // Accumulate the total duration for each objective
      if (!objectiveDurations[objective]) {
        objectiveDurations[objective] = 0;
      }
      objectiveDurations[objective] += duration;
    });

  // Calculate the total duration for all objectives
  const totalDuration = Object.values(objectiveDurations).reduce((sum, duration) => sum + duration, 0);

  // Prepare the table data
  let table = [];
  for (const [objective, duration] of Object.entries(objectiveDurations)) {
    const percentage = ((duration / totalDuration) * 100).toFixed(2) + "%";
    table.push([objective, duration, percentage]);
  }

  // Sort the table by total duration (descending)
  table.sort((a, b) => b[1] - a[1]);

  // Create a table to display the total durations by objective and their percentages
  dv.table(["Objective", "Total Duration (min)", "Percentage of Total Duration"], table);
}

```
