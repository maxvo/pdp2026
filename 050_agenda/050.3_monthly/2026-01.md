# Distribuição de horas por objetivo, resultados, entregas ou outros.
```dataviewjs
// Define the folder containing the daily notes
const folder = "050_agenda/050.1_daily";

// Parse the current file name to get the month and year
const currentFileName = dv.current().file.name; // Expected format: "2024-02"
const monthMatch = currentFileName.match(/(\d{4})-(\d{2})/);

// Ensure the file name matches the expected format
if (!monthMatch) {
  dv.paragraph(`Error: Current file name "${currentFileName}" is not in the expected format (YYYY-MM).`);
} else {
  const [_, yearStr, monthStr] = monthMatch;
  const year = parseInt(yearStr);
  const month = parseInt(monthStr);

  // Function to get the start and end dates of the month
  function getMonthDates(y, m) {
    // Month in JS Date is 0-indexed (0 = Jan, 1 = Feb)
    const start = new Date(y, m - 1, 1); 
    // day 0 of the next month gives the last day of the current month
    const end = new Date(y, m, 0); 
    return { start, end };
  }

  // Calculate the start and end dates for the current month
  const { start, end } = getMonthDates(year, month);

  // Initialize an object to store the sum of durations grouped by objective
  let objectiveDurations = {};

  // Query all pages in the specified folder
  dv.pages(`"${folder}"`)
    .file
    .tasks
    .forEach(task => {
      // Extract the date from the file name (assuming format is YYYY-MM-DD)
      const fileDateMatch = task.path.match(/(\d{4}-\d{2}-\d{2})/);

      // Skip tasks if the file date is not found
      if (!fileDateMatch) return;

      // Parse the file date for comparison
      const fileDate = fileDateMatch[1];
      const taskDate = new Date(fileDate);

      // Check if the task date is within the current month range
      // We compare timestamps to ensure accuracy
      if (taskDate.getTime() < start.getTime() || taskDate.getTime() > end.getTime()) return;

      // Extract the time range from the task description (e.g., "13:10 - 13:40")
      const timeRange = task.text.match(/(\d{2}):(\d{2}) - (\d{2}):(\d{2})/);
      if (!timeRange) return;

      // Convert times to minutes since midnight
      const startMinutes = parseInt(timeRange[1]) * 60 + parseInt(timeRange[2]);
      const endMinutes = parseInt(timeRange[3]) * 60 + parseInt(timeRange[4]);

      // Calculate the duration in minutes
      const duration = endMinutes - startMinutes;

      // Extract the objective link (if it exists)
      const objectiveMatch = task.text.match(/\[\[([^\]]+)\]\]/);
      const objective = objectiveMatch ? objectiveMatch[1] : "Entrega não cadastrada";

      // Accumulate the total duration for each objective
      if (!objectiveDurations[objective]) {
        objectiveDurations[objective] = 0;
      }
      objectiveDurations[objective] += duration;
    });

  // Calculate the total duration for all objectives
  const totalDuration = Object.values(objectiveDurations).reduce((sum, duration) => sum + duration, 0);

  // Prepare the table data
  let table = [];
  for (const [objective, duration] of Object.entries(objectiveDurations)) {
    const percentage = ((duration / totalDuration) * 100).toFixed(2) + "%";
    
    // Optional: Format duration to HH:MM for better readability on monthly view
    const hours = Math.floor(duration / 60);
    const mins = duration % 60;
    const readableDuration = `${hours}h ${mins}m`;

    table.push([objective, readableDuration, percentage, duration]); // Added raw duration for sorting
  }

  // Sort the table by raw total duration (descending) - index 3
  table.sort((a, b) => b[3] - a[3]);

  // Remove the raw duration from the display table
  const displayTable = table.map(row => [row[0], row[1], row[2]]);

  // Create a table to display the total durations by objective and their percentages
  dv.table(["Objective", "Total Duration", "Percentage"], displayTable);
}
```
